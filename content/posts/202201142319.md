+++
title = "bitboardアルゴリズムでN-Queen問題を解く"
lastmod = 2022-01-17T22:25:35+09:00
tags = ["Algorithm"]
draft = true
archives = ["2022", "2022-01"]
+++

## はじめに {#はじめに}

探索アルゴリズムを組むにあたって、配列を使うと効率が良くないので
ビット列を使って節約することが知られている。
自分もオセロのCPUアルゴリズムを組んでいるときにビットボードの存在を知った。
ビットボードは書いたことがなく面白そうだったので、比較的簡単なアルゴリズムで書けるN-Queenをbitboardで解いてみることにした。


## N-Queen問題 {#n-queen問題}

その名の通りだが、NxNのチェス版に、N個のクイーンを互いに取られない位置に配置する組み合わせを求める問題である。
クイーンは将棋の飛車と角行を組み合わせた動き、つまり縦横斜めに移動できるので、
その一直線上に複数のクイーンが配置されないようにする必要がある。


## 作ったもの {#作ったもの}

<https://github.com/grugrut/n-queen>

こちらで作成した。
言語はとくにこだわりなかったのでgolangで。

配列で素直に解くナイーブな解法と、bitboardを使う解法の二種類で書いている。
bitboardの場合はuint64で表現している都合上、変数1つでは8x8の盤面までしか表現できないので、
変数4つ使って16x16まで表現できるものも実装してみた。


## 時間計測 {#時間計測}

bitboardは省メモリももちろんだが高速化のために使われるので、
どれほど速度があがるかを見てみた。

| 盤面サイズ(NxN) | ナイーブ | bitboard |
|------------|------|----------|
| 4          | 0.002  | 0.002    |
| 5          | 0.002  | 0.002    |
| 6          | 0.003  | 0.003    |
| 7          | 0.01   | 0.008    |
| 8          | 0.065  | 0.035    |
| 9          | 0.632  | 0.239    |
| 10         | 6.592  | 1.876    |
| 11         | 75.598 | 16.512   |

8x8ぐらいの盤面までは、ほとんど大差ないが、9x9ぐらいから目に見えて時間が違ってきた。
11x11になると、とりうるクイーンの配置パターンが1200兆通りぐらいあるはずなので、
そこから効率的に探索ができているということがわかる。


## bitboardのしくみ {#bitboardのしくみ}
